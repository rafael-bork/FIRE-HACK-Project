<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FireROS | Grid-Based Fire Prediction</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        * {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }

        :root {
            --glass-bg: rgba(255, 255, 255, 0.808);
            --glass-border: rgb(255, 255, 255);
            --glass-shadow: 0 8px 32px rgba(0, 0, 0, 0.256);
            --text-primary: #1a1a1a;
            --text-secondary: #555555;
            --text-muted: #888888;
            --accent: #e85d04;
            --accent-light: rgba(232, 93, 4, 0.08);
        }

        body {
            background: #f5f5f5;
            color: var(--text-primary);
            overflow: hidden;
        }

        #map {
            position: fixed;
            inset: 0;
            z-index: 0;
        }

        .leaflet-container {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }

        .glass {
            background: var(--glass-bg);
            backdrop-filter: blur(32px);
            -webkit-backdrop-filter: blur(32px);
            border: 1px solid var(--glass-border);
            border-radius: 22px;
            box-shadow: var(--glass-shadow);
        }

        .input-field {
            background: rgba(255, 255, 255, 0.5);
            border: 1px solid rgba(0, 0, 0, 0.06);
            border-radius: 10px;
            padding: 11px 14px;
            color: var(--text-primary);
            font-size: 13px;
            transition: all 0.2s ease;
            width: 100%;
        }

        .input-field:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 0 3px var(--accent-light);
        }

        .select-field {
            background: rgba(255, 255, 255, 0.5);
            border: 1px solid rgba(0, 0, 0, 0.06);
            border-radius: 10px;
            padding: 11px 32px 11px 14px;
            color: var(--text-primary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            appearance: none;
            width: 100%;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 24 24' fill='none' stroke='%23666' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
        }

        .select-field:focus {
            outline: none;
            border-color: var(--accent);
            background-color: rgba(255, 255, 255, 0.8);
        }

        .btn-primary {
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 12px;
            padding: 14px 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
        }

        .btn-primary:hover {
            background: #d45203;
            transform: translateY(-1px);
            box-shadow: 0 8px 20px rgba(232, 93, 4, 0.35);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .label {
            font-size: 12px;
            font-weight: 800;
            letter-spacing: 0.01em;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 8px;
            display: block;
        }

        .hint {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 6px;
        }

        .stat-value {
            font-size: 22px;
            font-weight: 500;
            letter-spacing: -0.02em;
            line-height: 1;
        }

        .stat-label {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-top: 4px;
        }

        .gradient-bar {
            height: 12px;
            border-radius: 6px;
            background: linear-gradient(to right, #22c55e, #84cc16, #eab308, #f97316, #ef4444, #b91c1c);
        }

        .gradient-bar.displacement {
            background: linear-gradient(to right, #22c55e, #84cc16, #eab308, #f97316, #ef4444, #b91c1c);
        }

        .gradient-bar.input-var {
            background: linear-gradient(to right, #22c55e, #84cc16, #eab308, #f97316, #ef4444, #b91c1c);
        }

        .gradient-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
        }

        .gradient-labels span {
            font-size: 10px;
            color: var(--text-muted);
        }

        .toggle-container {
            display: flex;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 10px;
            padding: 3px;
            gap: 3px;
        }

        .toggle-btn {
            flex: 1;
            padding: 8px 12px;
            font-size: 11px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: transparent;
            color: var(--text-muted);
        }

        .toggle-btn.active {
            background: white;
            color: var(--text-primary);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .loader {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(0, 0, 0, 0.08);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .leaflet-popup-content-wrapper {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 14px;
            box-shadow: var(--glass-shadow);
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }

        .leaflet-popup-tip {
            background: var(--glass-bg);
        }

        ::-webkit-scrollbar {
            width: 4px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.12);
            border-radius: 2px;
        }

        .divider {
            height: 1px;
            background: rgba(0, 0, 0, 0.06);
            margin: 16px 0;
        }

        .hidden {
            display: none;
        }

        /* ==================== */
        /* STATUS POPUP STYLES */
        /* ==================== */
        
        .status-popup {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2001;
            display: none;
        }

        .status-popup.visible {
            display: block;
        }

        .status-pill {
            background: rgba(255, 255, 255, 0.92);
            backdrop-filter: blur(40px);
            -webkit-backdrop-filter: blur(40px);
            border: 1px solid rgba(255, 255, 255, 0.95);
            border-radius: 50px;
            box-shadow: 
                0 4px 24px rgba(0, 0, 0, 0.12),
                0 0 0 1px rgba(255, 255, 255, 0.1) inset;
            padding: 12px 24px;
            display: flex;
            align-items: center;
            gap: 14px;
            min-width: 200px;
            
            /* Animation */
            opacity: 0;
            transform: translateY(-20px);
            animation: statusEnter 0.4s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }

        @keyframes statusEnter {
            0% {
                opacity: 0;
                transform: translateY(-20px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .status-popup.hiding .status-pill {
            animation: statusExit 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }

        @keyframes statusExit {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        .status-spinner {
            width: 18px;
            height: 18px;
            border: 2.5px solid rgba(232, 93, 4, 0.15);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            flex-shrink: 0;
        }

        .status-content {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .status-message {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
        }

        .status-detail {
            font-size: 11px;
            color: var(--text-muted);
            white-space: nowrap;
        }

        .status-success-icon {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #22c55e;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .status-success-icon svg {
            width: 10px;
            height: 10px;
            color: white;
        }

        .status-error-icon {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ef4444;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .status-error-icon svg {
            width: 10px;
            height: 10px;
            color: white;
        }

        /* ==================== */
        /* WELCOME OVERLAY STYLES */
        /* ==================== */
        
        .welcome-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 10;
            z-index: 2000;
            display: flex;
            justify-content: center;
            padding-top: 80px;
            pointer-events: none;
        }

        .welcome-overlay.dismissed {
            display: none;
        }

        .welcome-card {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(40px);
            -webkit-backdrop-filter: blur(40px);
            border: 1px solid rgba(255, 255, 255, 0.9);
            border-radius: 24px;
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.421),
                0 0 0 1px rgba(255, 255, 255, 0.1) inset;
            padding: 32px 40px;
            text-align: center;
            pointer-events: auto;
            position: relative;
            overflow: hidden;
            max-width: 360px;
            width: 90%;
            
            /* Initial state for animation */
            opacity: 0;
            transform: translateY(-30px) scale(0.95);
            animation: welcomeEnter 0.8s cubic-bezier(0.16, 1, 0.3, 1) forwards;
            animation-delay: 0.3s;
        }

        @keyframes welcomeEnter {
            0% {
                opacity: 0;
                transform: translateY(-30px) scale(0.95);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        /* Subtle gradient overlay */
        .welcome-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100px;
            background: linear-gradient(180deg, rgba(232, 91, 4, 0.087) 0%, transparent 100%);
            pointer-events: none;
        }

        .welcome-close-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: none;
            background: rgba(0, 0, 0, 0.05);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
            opacity: 0;
            animation: fadeIn 0.4s ease forwards;
            animation-delay: 0.9s;
        }

        .welcome-close-btn:hover {
            background: rgba(0, 0, 0, 0.1);
            transform: scale(1.1);
        }

        .welcome-close-btn:active {
            transform: scale(0.95);
        }

        .welcome-close-btn svg {
            width: 14px;
            height: 14px;
            color: var(--text-muted);
            transition: color 0.2s ease;
        }

        .welcome-close-btn:hover svg {
            color: var(--text-primary);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .welcome-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto 16px;
            background: linear-gradient(135deg, #e85d04 0%, #f97316 100%);
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 24px rgba(232, 93, 4, 0.25);
            opacity: 0;
            transform: scale(0.8);
            animation: iconEnter 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards;
            animation-delay: 0.6s;
        }

        @keyframes iconEnter {
            0% {
                opacity: 0;
                transform: scale(0.8);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        .welcome-icon svg {
            width: 26px;
            height: 26px;
            color: white;
        }

        .welcome-title {
            font-size: 28px;
            font-weight: 600;
            letter-spacing: -0.03em;
            color: var(--text-primary);
            margin-bottom: 8px;
            opacity: 0;
            transform: translateY(10px);
            animation: textEnter 0.5s ease forwards;
            animation-delay: 0.7s;
        }

        .welcome-subtitle {
            font-size: 14px;
            color: var(--text-muted);
            margin-bottom: 20px;
            opacity: 0;
            transform: translateY(10px);
            animation: textEnter 0.5s ease forwards;
            animation-delay: 0.8s;
        }

        @keyframes textEnter {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .welcome-arrow-btn {
            width: 40px;
            height: 40px;
            margin: 0 auto;
            border: none;
            background: rgba(232, 93, 4, 0.08);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            opacity: 0;
            animation: arrowEnter 0.5s ease forwards;
            animation-delay: 0.9s;
        }

        @keyframes arrowEnter {
            from {
                opacity: 0;
                transform: translateY(-5px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .welcome-arrow-btn:hover {
            background: rgba(232, 93, 4, 0.15);
            transform: scale(1.1);
        }

        .welcome-arrow-btn:active {
            transform: scale(0.95);
        }

        .welcome-arrow-btn svg {
            width: 20px;
            height: 20px;
            color: var(--accent);
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .welcome-card.expanded .welcome-arrow-btn svg {
            transform: rotate(180deg);
        }

        /* Bounce animation for arrow */
        .welcome-arrow-btn:not(:hover) svg {
            animation: arrowBounce 2s ease-in-out infinite;
            animation-delay: 1.5s;
        }

        @keyframes arrowBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(4px); }
        }

        .welcome-card.expanded .welcome-arrow-btn:not(:hover) svg {
            animation: none;
        }

        /* Expandable content */
        .welcome-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s cubic-bezier(0.16, 1, 0.3, 1), 
                        margin-top 0.5s cubic-bezier(0.16, 1, 0.3, 1),
                        opacity 0.4s ease;
            opacity: 0;
        }

        .welcome-card.expanded .welcome-content {
            max-height: 300px;
            margin-top: 20px;
            opacity: 1;
        }

        .welcome-content-inner {
            padding-top: 20px;
            border-top: 1px solid rgba(0, 0, 0, 0.06);
            text-align: left;
        }

        .welcome-greeting {
            font-size: 13px;
            line-height: 1.7;
            color: var(--text-secondary);
        }

        .welcome-greeting p {
            margin-bottom: 12px;
        }

        .welcome-greeting p:last-child {
            margin-bottom: 0;
        }

        .welcome-greeting strong {
            color: var(--text-primary);
            font-weight: 600;
        }

        .welcome-greeting .highlight {
            color: var(--accent);
            font-weight: 600;
        }

        .welcome-feature-list {
            margin: 16px 0;
            padding: 0;
            list-style: none;
        }

        .welcome-feature-list li {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .welcome-feature-list li:last-child {
            margin-bottom: 0;
        }

        .welcome-feature-icon {
            width: 18px;
            height: 18px;
            border-radius: 5px;
            background: rgba(232, 93, 4, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            margin-top: 1px;
        }

        .welcome-feature-icon svg {
            width: 10px;
            height: 10px;
            color: var(--accent);
        }

        /* Dismiss animation */
        .welcome-card.dismissing {
            animation: welcomeExit 0.4s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }

        @keyframes welcomeExit {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
            }
        }

        /* Timeline Styles */
        .timeline-container {
            padding: 0 4px;
        }

        .timeline-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(0, 0, 0, 0.1);
            outline: none;
            cursor: pointer;
        }

        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(232, 93, 4, 0.4);
            transition: transform 0.15s ease;
        }

        .timeline-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .timeline-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(232, 93, 4, 0.4);
        }

        .timeline-ticks {
            display: flex;
            justify-content: space-between;
            padding: 8px 0 0 0;
        }

        .timeline-tick {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .timeline-tick:hover .tick-label {
            color: var(--accent);
        }

        .tick-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.15);
            margin-bottom: 4px;
            transition: all 0.2s ease;
        }

        .timeline-tick.active .tick-dot {
            background: var(--accent);
            transform: scale(1.3);
        }

        .tick-label {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-muted);
            transition: color 0.2s ease;
        }

        .timeline-tick.active .tick-label {
            color: var(--accent);
        }

        .duration-display {
            text-align: center;
            padding: 8px 0;
        }

        .duration-value {
            font-size: 28px;
            font-weight: 600;
            color: var(--accent);
            line-height: 1;
        }

        .duration-unit {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-top: 4px;
        }

        /* Playback controls */
        .playback-controls {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 12px;
        }

        .playback-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            background: rgba(0, 0, 0, 0.05);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .playback-btn:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        .playback-btn.play-btn {
            width: 44px;
            height: 44px;
            background: var(--accent);
        }

        .playback-btn.play-btn:hover {
            background: #d45203;
            transform: scale(1.05);
        }

        .playback-btn svg {
            width: 16px;
            height: 16px;
            color: var(--text-secondary);
        }

        .playback-btn.play-btn svg {
            color: white;
            width: 18px;
            height: 18px;
        }

        /* Map Layer Buttons */
        .map-layer-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .map-layer-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 6px 4px;
            background: rgba(255, 255, 255, 0.5);
            border: 1.5px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .map-layer-btn:hover {
            background: rgba(255, 255, 255, 0.8);
        }

        .map-layer-btn.active {
            border-color: var(--accent);
            background: rgba(232, 93, 4, 0.08);
        }

        .map-layer-btn svg {
            width: 14px;
            height: 14px;
            color: var(--text-secondary);
            margin-bottom: 2px;
        }

        .map-layer-btn.active svg {
            color: var(--accent);
        }

        .map-layer-btn span {
            font-size: 9px;
            font-weight: 600;
            color: var(--text-muted);
        }

        .map-layer-btn.active span {
            color: var(--accent);
        }

        /* Info Tooltip */
        .label-with-info {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .label-with-info .label {
            margin-bottom: 0;
        }

        .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.08);
            color: var(--text-muted);
            font-size: 10px;
            font-weight: 700;
            cursor: help;
            margin-left: 6px;
            transition: all 0.2s ease;
            position: relative;
            flex-shrink: 0;
        }

        .info-icon:hover {
            background: var(--accent);
            color: white;
        }

        .info-tooltip-wrapper {
            position: relative;
            display: inline-flex;
            align-items: center;
        }

        .info-tooltip {
            position: absolute;
            left: calc(100% + 12px);
            top: 50%;
            width: 220px;
            padding: 14px 16px;
            background: var(--glass-bg);
            backdrop-filter: blur(32px);
            -webkit-backdrop-filter: blur(32px);
            border: 1px solid var(--glass-border);
            border-radius: 14px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.12);
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            z-index: 1001;
            pointer-events: none;
        }

        .info-tooltip::before {
            content: '';
            position: absolute;
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
            border: 6px solid transparent;
            border-right-color: var(--glass-border);
        }

        .info-tooltip::after {
            content: '';
            position: absolute;
            left: -5px;
            top: 50%;
            transform: translateY(-50%);
            border: 5px solid transparent;
            border-right-color: var(--glass-bg);
        }

        .info-icon:hover + .info-tooltip,
        .info-tooltip:hover {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        .info-tooltip-title {
            font-size: 12px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 10px;
        }

        .info-tooltip-content {
            font-size: 11px;
            line-height: 1.5;
            color: var(--text-secondary);
        }

        .info-tooltip-content p {
            margin-bottom: 10px;
        }

        .info-tooltip-content p:last-child {
            margin-bottom: 0;
        }

        .info-tooltip-content strong {
            color: var(--text-primary);
            font-weight: 600;
        }

        /* Warning message */
        .field-warning {
            display: flex;
            align-items: flex-start;
            gap: 5px;
            margin-top: 8px;
            padding: 6px 8px;
            background: rgba(239, 68, 68, 0.08);
            border-radius: 6px;
            font-size: 10px;
            color: #dc2626;
            line-height: 1.4;
        }

        .field-warning svg {
            width: 12px;
            height: 12px;
            flex-shrink: 0;
            margin-top: 1px;
        }

        .field-warning.hidden {
            display: none;
        }

        /* ==================== */
        /* CHART PANE STYLES */
        /* ==================== */
        
        .chart-pane-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            z-index: 3000;
            display: none;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .chart-pane-overlay.visible {
            display: flex;
            opacity: 1;
        }

        .chart-pane {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(40px);
            -webkit-backdrop-filter: blur(40px);
            border: 1px solid rgba(255, 255, 255, 0.9);
            border-radius: 24px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.35);
            padding: 28px 32px;
            width: 90%;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            transform: translateY(20px) scale(0.95);
            opacity: 0;
            animation: chartPaneEnter 0.4s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }

        @keyframes chartPaneEnter {
            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        .chart-pane-overlay.hiding .chart-pane {
            animation: chartPaneExit 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }

        @keyframes chartPaneExit {
            to {
                transform: translateY(20px) scale(0.95);
                opacity: 0;
            }
        }

        .chart-pane-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 24px;
        }

        .chart-pane-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            letter-spacing: -0.02em;
        }

        .chart-pane-subtitle {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 4px;
        }

        .chart-pane-close {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: none;
            background: rgba(0, 0, 0, 0.05);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .chart-pane-close:hover {
            background: rgba(0, 0, 0, 0.1);
            transform: scale(1.1);
        }

        .chart-pane-close svg {
            width: 16px;
            height: 16px;
            color: var(--text-muted);
        }

        .chart-container {
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(0, 0, 0, 0.04);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .chart-container:last-child {
            margin-bottom: 0;
        }

        .chart-label {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }

        .chart-wrapper {
            position: relative;
            height: 200px;
        }

        /* Popup chart button */
        .popup-chart-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-top: 10px;
            padding: 8px 14px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .popup-chart-btn:hover {
            background: #d45203;
            transform: translateY(-1px);
        }

        .popup-chart-btn svg {
            width: 14px;
            height: 14px;
        }

        /* Export Button Styles */
        .btn-export {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            padding: 10px 14px;
            background: rgba(255, 255, 255, 0.6);
            border: 1.5px solid rgba(0, 0, 0, 0.08);
            border-radius: 10px;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-export:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.9);
            border-color: var(--accent);
            color: var(--accent);
        }

        .btn-export:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-export svg {
            width: 16px;
            height: 16px;
        }
    </style>
</head>

<body class="h-screen">

    <!-- Chart Pane Overlay -->
    <div class="chart-pane-overlay" id="chart-pane-overlay" onclick="closeChartPane(event)">
        <div class="chart-pane" onclick="event.stopPropagation()">
            <div class="chart-pane-header">
                <div>
                    <div class="chart-pane-title">Cell Analysis</div>
                    <div class="chart-pane-subtitle" id="chart-pane-coords">Lat: —, Lon: —</div>
                </div>
                <button class="chart-pane-close" onclick="closeChartPane()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
            
            <!-- ROS vs Duration Chart -->
            <div class="chart-container">
                <div class="chart-label">Rate of Spread vs Duration</div>
                <div class="chart-wrapper">
                    <canvas id="ros-chart"></canvas>
                </div>
            </div>
            
            <!-- Distance vs Duration Chart -->
            <div class="chart-container">
                <div class="chart-label">Distance vs Duration</div>
                <div class="chart-wrapper">
                    <canvas id="increment-chart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Status Popup -->
    <div class="status-popup" id="status-popup">
        <div class="status-pill" id="status-pill">
            <div class="status-spinner" id="status-spinner"></div>
            <div class="status-success-icon hidden" id="status-success-icon">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
            </div>
            <div class="status-error-icon hidden" id="status-error-icon">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </div>
            <div class="status-content">
                <div class="status-message" id="status-message">Processing...</div>
                <div class="status-detail" id="status-detail">Initializing request</div>
            </div>
        </div>
    </div>

    <!-- Welcome Overlay -->
    <div class="welcome-overlay" id="welcome-overlay">
        <div class="welcome-card" id="welcome-card">
            <!-- Close Button -->
            <button class="welcome-close-btn" onclick="dismissWelcome()" title="Close">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>

            <!-- Title -->
            <h1 class="welcome-title">Welcome!</h1>


                <div class="welcome-content-inner">
                    <div class="welcome-greeting">
                        <p>This is a grid-based fire spread prediction system for Portugal.</p>
                        
                        <ul class="welcome-feature-list">
                            <li>
                                <span class="welcome-feature-icon">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                                        <polyline points="20 6 9 17 4 12"></polyline>
                                    </svg>
                                </span>
                                <span>Predict fire <span class="highlight">Rate of Spread</span> across 0.1° grid cells.</span>
                            </li>
                            <li>
                                <span class="welcome-feature-icon">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                                        <polyline points="20 6 9 17 4 12"></polyline>
                                    </svg>
                                </span>
                                <span>Automatic weather and fuel data integration.</span>
                            </li>
                            <li>
                                <span class="welcome-feature-icon">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                                        <polyline points="20 6 9 17 4 12"></polyline>
                                    </svg>
                                </span>
                                <span>Timeline playback for temporal analysis.</span>
                            </li>
                            <li>
                                <span class="welcome-feature-icon">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                                        <polyline points="20 6 9 17 4 12"></polyline>
                                    </svg>
                                </span>
                                <span>Two models available, XGBoost and linear model.</span>
                            </li>
                        </ul>

                        <p style="margin-top: 16px; font-size: 12px; color: var(--text-muted);">Use the panel on the left to configure your prediction parameters and click <strong>Run Prediction</strong> to begin.</p>
                    </div>
                </div>
        </div>
    </div>

    <!-- Fullscreen Map -->
    <div id="map"></div>

    <!-- Instructions Panel (Top Right) -->
    <div class="fixed top-4 right-4 z-[1000]" style="width: 280px;">
        <div class="glass p-5">
            <div class="label mb-3">Instructions</div>
            <div class="space-y-2">
                <div class="flex gap-3">
                    <span class="text-[11px] font-semibold text-orange-500">1</span>
                    <p class="text-[11px] text-gray-600 leading-relaxed">Select desired model.</p>
                </div>
                <div class="flex gap-3">
                    <span class="text-[11px] font-semibold text-orange-500">2</span>
                    <p class="text-[11px] text-gray-600 leading-relaxed">Select fire event date & time.</p>
                </div>
                <div class="flex gap-3">
                    <span class="text-[11px] font-semibold text-orange-500">3</span>
                    <p class="text-[11px] text-gray-600 leading-relaxed">Set prediction duration.</p>
                </div>
                <div class="flex gap-3">
                    <span class="text-[11px] font-semibold text-orange-500">4</span>
                    <p class="text-[11px] text-gray-600 leading-relaxed">Adjust fire start time if needed.</p>
                </div>
                <div class="flex gap-3">
                    <span class="text-[11px] font-semibold text-orange-500">5</span>
                    <p class="text-[11px] text-gray-600 leading-relaxed">Click on "Run Prediction" to run the model.</p>
                </div>
            </div>
            <p class="text-[10px] text-gray-400 mt-3 leading-relaxed">Weather, fuel load, and burned area data is automatically fetched.</p>
        </div>

        <!-- Map Layers Panel -->
        <div class="glass p-3 mt-3">
            <div class="label mb-2" style="font-size: 10px;">Map Style</div>
            <div class="map-layer-grid">
                <button class="map-layer-btn active" id="layer-default" onclick="setMapLayer('default')">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="18" rx="2"/>
                        <path d="M3 9h18"/>
                        <path d="M9 21V9"/>
                    </svg>
                    <span>Default</span>
                </button>
                <button class="map-layer-btn" id="layer-satellite" onclick="setMapLayer('satellite')">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"/>
                        <path d="M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20"/>
                        <path d="M2 12h20"/>
                    </svg>
                    <span>Satellite</span>
                </button>
                <button class="map-layer-btn" id="layer-terrain" onclick="setMapLayer('terrain')">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M8 3l4 8 5-5 5 15H2L8 3z"/>
                    </svg>
                    <span>Terrain</span>
                </button>
            </div>
        </div>

        <!-- Export Panel -->
        <div class="glass p-3 mt-3">
            <div class="label mb-2" style="font-size: 10px;">Export Data</div>
            <button class="btn-export" id="export-csv-btn" onclick="exportToCSV()" disabled>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7 10 12 15 17 10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                </svg>
                <span>Export CSV</span>
            </button>
            <p class="hint mt-2">Export all predictions and inputs for each cell.</p>
        </div>
    </div>

    <!-- Exportar para csv-->

    <div class="info-tooltip-wrapper" style="margin-left: 310px; margin-top: 20px;"> 
                                <span class="info-icon" style="font-size: 18px; color: rgba(255, 0, 0, 0.483); width: 28px; height: 28px;">?</span>
                                <div class="info-tooltip" style="width: 350px;">
                                    <div class="info-tooltip-title">Geographical Variables</div>
                                    <div class="info-tooltip-content">
                                        <p>Geographic variables were extracted by overlaying fire progression polygons on raster data. Continuous variables (elevation, aspect, fuel load) used spatial averages, while categorical variables (landform, fuel model, land use) used spatial modes. Fire history was computed as percentage of area burned in different time windows.</p>
                                    </div>
                                    <div class="info-tooltip-title" style="padding-top: 12px;">Metereological Variables</div>
                                    <div class="info-tooltip-content">
                                        <p>Meteorological data from ERA5 and ERA5 Land was consolidated into a 0.1° grid. Hourly spatial averages were computed first, then temporal averages across each progression's duration. Secondary variables (VPD, DFMC, wind shear, stability indices) were derived before aggregation.</p>
                                    </div>
                                    <div class="info-tooltip-title" style="padding-top: 12px;">Data Filtering</div>
                                    <div class="info-tooltip-content">
                                        <p>Only progressions with known start/end times (Rank 1 and 2) were used. Training used 1,177 of 3,367 available progressions from the PT-FireSprd L2 database.</p>
                                    </div>
                                </div>
        </div>



    <!-- Floating Sidebar -->
    <aside class="fixed top-4 left-4 z-[1000] w-72">
        <!-- Input Parameters Panel -->
        <div class="glass p-5">
            <div class="space-y-4">
                
                <!-- Model -->
                <div>
                    <div class="label-with-info">
                        <label class="label">Model</label>
                        <div class="info-tooltip-wrapper">
                            <span class="info-icon">i</span>
                            <div class="info-tooltip">
                                <div class="info-tooltip-title">Model Selection</div>
                                <div class="info-tooltip-content">
                                    <p><strong>Complex Model:</strong> XGBoost ensemble with full feature set including weather, fuel load, and historical burn data. Higher accuracy for varied conditions.</p>
                                    <p><strong>Linear Model:</strong> Simplified linear regression using core predictors. Faster computation, better interpretability.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <select id="model-selector" class="select-field">
                        <option value="complex" selected>Complex Model</option>
                        <option value="linear">Linear Model</option>
                    </select>
                </div>

                <!-- DateTime -->
                <div>
                    <label class="label">Date & Time</label>
                    <input type="datetime-local" id="datetime-input" class="input-field" required>
                    <p class="hint">Possible prediction window from January 1, 2015, to three months prior to the present.</p>
                </div>

                <!-- Duration -->
                <div>
                    <label class="label">Duration (hours)</label>
                    <input type="number" id="duration-input" value="1" min="1" max="24" step="1" class="input-field">
                </div>

                <!-- f_start -->
                <div>
                    <label class="label">Time Since Start</label>
                    <div style="display: flex; gap: 8px;">
                        <div style="flex: 1;">
                            <input type="number" id="f-start-hours" value="0" min="0" step="1" class="input-field" oninput="syncFromHours()">
                            <p class="hint">Hours</p>
                        </div>
                        <div style="flex: 1;">
                            <input type="number" id="f-start-minutes" value="0" min="0" step="1" class="input-field" oninput="syncFromMinutes()">
                            <p class="hint">Minutes</p>
                        </div>
                    </div>
                    <!-- Warning for high time since start values -->
                    <div id="f-start-warning" class="field-warning hidden">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                        </svg>
                        <span>Warning: Rate of spreads above 1000 m/h can have high errors.</span>
                    </div>
                </div>

            </div>
        </div>
    </aside>

    <!-- Display Options Panel -->
    <div class="glass p-5 fixed bottom-4 left-4 w-72 z-[1000]">
        <div class="space-y-4">
                <!-- Display Mode Toggle -->
                <div>
                    <div class="label mb-3">Display Layer</div>
                    <div class="toggle-container">
                        <button class="toggle-btn active" id="toggle-ros" onclick="setViewMode('ros')">ROS</button>
                        <button class="toggle-btn" id="toggle-displacement" onclick="setViewMode('displacement')">Distance</button>
                        <button class="toggle-btn" id="toggle-inputs" onclick="setViewMode('inputs')">Inputs</button>
                    </div>
                </div>

                <!-- Metric Toggle (for ROS/Displacement modes) -->
                <div id="metric-toggle-container">
                    <div class="label mb-3">Metric</div>
                    <div class="toggle-container">
                        <button class="toggle-btn active" id="toggle-cumulative" onclick="setMetricMode('cumulative')">Cumulative</button>
                        <button class="toggle-btn" id="toggle-increment" onclick="setMetricMode('increment')">Increment</button>
                    </div>
                </div>

                <!-- Input Variable Selector (hidden by default) -->
                <div id="input-var-selector-container" class="hidden">
                    <label class="label">Variable</label>
                    <select id="input-var-selector" class="select-field" onchange="updateInputVarDisplay()">
                        <option value="fuel_load">Fuel Load (tons/ha)</option>
                        <option value="pct_3_8">Percentage of area burned between 3 and 8 years ago</option>
                        <option value="pct_8p">Percentage of area burned more than 8 years ago</option>
                        <option value="wv100_kh">Wind at 100m (km/h)</option>
                        <option value="FWI_12h">Fire Weather Index</option>
                    </select>
                </div>

                <!-- Legend - ROS -->
                <div id="legend-ros">
                    <div class="label mb-3" id="ros-legend-title">Rate of Spread (m/hr)</div>
                    <div class="gradient-bar"></div>
                    <div class="gradient-labels" id="ros-legend-labels">
                        <span>0</span>
                        <span>500</span>
                        <span>1000</span>
                        <span>1500</span>
                        <span>2000</span>
                        <span>2500</span>
                    </div>
                </div>

                <!-- Legend - Displacement -->
                <div class="hidden" id="legend-displacement">
                    <div class="label mb-3" id="displacement-legend-title">Distance Traveled (m)</div>
                    <div class="gradient-bar displacement"></div>
                    <div class="gradient-labels" id="displacement-legend-labels">
                        <span>0</span>
                        <span>—</span>
                        <span>—</span>
                        <span>—</span>
                        <span>Max</span>
                    </div>
                </div>

                <!-- Legend - Input Variables -->
                <div class="hidden" id="legend-inputs">
                    <div class="label mb-3" id="input-var-legend-title">Fuel Load</div>
                    <div class="gradient-bar input-var"></div>
                    <div class="gradient-labels" id="input-var-legend-labels">
                        <span>0</span>
                        <span>—</span>
                        <span>—</span>
                        <span>—</span>
                        <span>Max</span>
                    </div>
                </div>

                <!-- Run Button -->
                <button onclick="runGridPrediction()" class="btn-primary" id="run-btn">
                    Run Prediction
                </button>

            </div>
        </div>
    </div>

    <!-- Timeline Panel (hidden until predictions are loaded) -->
    <div class="fixed bottom-4 z-[1000] hidden" id="timeline-panel" style="right: 60px;">
        <div class="glass px-6 py-5" style="width: 320px;">
            <div class="label mb-2">Timeline</div>
            
            <!-- Duration Display -->
            <div class="duration-display">
                <div class="duration-value" id="current-duration-display">0-1h</div>
                <div class="duration-unit" id="duration-unit-label">hours</div>
            </div>
            
            <!-- Timeline Slider -->
            <div class="timeline-container">
                <input type="range" 
                       id="timeline-slider" 
                       class="timeline-slider" 
                       min="1" 
                       max="1" 
                       value="1" 
                       step="1"
                       oninput="onTimelineChange(this.value)">
                <div class="timeline-ticks" id="timeline-ticks"></div>
            </div>
            
            <!-- Playback Controls -->
            <div class="playback-controls">
                <button class="playback-btn" onclick="stepBackward()" title="Previous">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 20L9 12l10-8v16z"/>
                        <line x1="5" y1="4" x2="5" y2="20"/>
                    </svg>
                </button>
                <button class="playback-btn play-btn" id="play-btn" onclick="togglePlayback()" title="Play">
                    <svg viewBox="0 0 24 24" fill="currentColor" id="play-icon">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                    <svg viewBox="0 0 24 24" fill="currentColor" id="pause-icon" class="hidden">
                        <rect x="6" y="4" width="4" height="16"/>
                        <rect x="14" y="4" width="4" height="16"/>
                    </svg>
                </button>
                <button class="playback-btn" onclick="stepForward()" title="Next">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M5 4l10 8-10 8V4z"/>
                        <line x1="19" y1="4" x2="19" y2="20"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <!-- Bottom Results Bar -->
    <div class="fixed bottom-4 left-1/2 -translate-x-1/2 z-[1000]">
        <div class="glass px-8 py-3">
            <div class="flex items-center gap-8">
                <div class="text-center">
                    <div class="stat-value text-emerald-600" id="min-ros-output">—</div>
                    <div class="stat-label" id="min-label">Min m/hr</div>
                </div>
                <div class="w-px h-10 bg-black/5"></div>
                <div class="text-center">
                    <div class="stat-value text-orange-600" id="avg-ros-output">—</div>
                    <div class="stat-label" id="avg-label">Avg m/hr</div>
                </div>
                <div class="w-px h-10 bg-black/5"></div>
                <div class="text-center">
                    <div class="stat-value text-red-500" id="max-ros-output">—</div>
                    <div class="stat-label" id="max-label">Max m/hr</div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        // --- EXPORT TO CSV FUNCTION ---
        function exportToCSV() {
            if (Object.keys(predictionsByDuration).length === 0) {
                showStatusError('No Data', 'Run a prediction first to export data.');
                return;
            }

            // Build CSV header
            const headers = [
                'duration_hours',
                'latitude',
                'longitude',
                'ros_mh',
                'ros_increment_mh',
                'displacement_m',
                'displacement_increment_m',
                'error_estimate',
                'fuel_load',
                'pct_3_8',
                'pct_8p',
                'wv100_kh',
                'FWI_12h'
            ];

            const rows = [headers.join(',')];

            // Iterate through all durations and predictions
            for (const dur of availableDurations) {
                const predictions = predictionsByDuration[dur] || [];
                for (const p of predictions) {
                    const row = [
                        dur,
                        p.lat.toFixed(4),
                        p.lon.toFixed(4),
                        p.ros.toFixed(4),
                        (p.ros_increment || 0).toFixed(4),
                        p.displacement.toFixed(4),
                        (p.increment || 0).toFixed(4),
                        p.error_estimate.toFixed(4),
                        p.input_vars?.fuel_load?.toFixed(4) ?? '',
                        p.input_vars?.pct_3_8?.toFixed(4) ?? '',
                        p.input_vars?.pct_8p?.toFixed(4) ?? '',
                        p.input_vars?.wv100_kh?.toFixed(4) ?? '',
                        p.input_vars?.FWI_12h?.toFixed(4) ?? ''
                    ];
                    rows.push(row.join(','));
                }
            }

            // Create and download CSV
            const csvContent = rows.join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.setAttribute('href', url);
            
            // Generate filename with timestamp
            const datetime = document.getElementById('datetime-input').value || 'prediction';
            const timestamp = datetime.replace(/[:\s]/g, '-').replace('T', '_');
            link.setAttribute('download', `fireros_predictions_${timestamp}.csv`);
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            showStatusSuccess('Export Complete', `${rows.length - 1} records exported`);
        }

        // Function to enable/disable export button based on data availability
        function updateExportButtonState() {
            const exportBtn = document.getElementById('export-csv-btn');
            if (Object.keys(predictionsByDuration).length > 0) {
                exportBtn.disabled = false;
            } else {
                exportBtn.disabled = true;
            }
        }

        // --- CHART PANE FUNCTIONS ---
        let rosChart = null;
        let incrementChart = null;

        function openChartPane(lat, lon) {
            const overlay = document.getElementById('chart-pane-overlay');
            document.getElementById('chart-pane-coords').innerText = `Lat: ${lat.toFixed(4)}, Lon: ${lon.toFixed(4)}`;
            
            overlay.classList.add('visible');
            
            // Close any open popups
            map.closePopup();
            
            // Render charts
            renderCellCharts(lat, lon);
        }

        function closeChartPane(event) {
            if (event && event.target !== event.currentTarget) return;
            
            const overlay = document.getElementById('chart-pane-overlay');
            overlay.classList.add('hiding');
            
            setTimeout(() => {
                overlay.classList.remove('visible', 'hiding');
                
                // Destroy charts
                if (rosChart) {
                    rosChart.destroy();
                    rosChart = null;
                }
                if (incrementChart) {
                    incrementChart.destroy();
                    incrementChart = null;
                }
            }, 300);
        }

        function getCellDataAcrossDurations(lat, lon) {
            const data = {
                durations: [],
                ros: [],
                rosIncrement: [],
                displacement: [],
                distanceIncrement: []
            };
            
            for (const dur of availableDurations) {
                const predictions = predictionsByDuration[dur] || [];
                const cellPred = predictions.find(p => 
                    Math.abs(p.lat - lat) < 0.001 && Math.abs(p.lon - lon) < 0.001
                );
                
                if (cellPred) {
                    data.durations.push(dur);
                    data.ros.push(cellPred.ros);
                    data.rosIncrement.push(cellPred.ros_increment || 0);
                    data.displacement.push(cellPred.displacement);
                    data.distanceIncrement.push(cellPred.increment || 0);
                }
            }
            
            return data;
        }

        function renderCellCharts(lat, lon) {
            const cellData = getCellDataAcrossDurations(lat, lon);
            
            if (cellData.durations.length === 0) {
                return;
            }
            
            const labels = cellData.durations.map(d => `${d}h`);
            
            // Destroy existing charts
            if (rosChart) rosChart.destroy();
            if (incrementChart) incrementChart.destroy();
            
            // Chart.js common options
            const commonOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            font: {
                                family: "'Helvetica Neue', Helvetica, Arial, sans-serif",
                                size: 11,
                                weight: '600'
                            },
                            color: '#555',
                            usePointStyle: true,
                            pointStyle: 'circle',
                            padding: 16
                        }
                    }
                },
                scales: {
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            font: {
                                family: "'Helvetica Neue', Helvetica, Arial, sans-serif",
                                size: 11
                            },
                            color: '#888'
                        },
                        title: {
                            display: true,
                            text: 'Duration',
                            font: {
                                family: "'Helvetica Neue', Helvetica, Arial, sans-serif",
                                size: 11,
                                weight: '600'
                            },
                            color: '#555'
                        }
                    },
                    y: {
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        },
                        ticks: {
                            font: {
                                family: "'Helvetica Neue', Helvetica, Arial, sans-serif",
                                size: 11
                            },
                            color: '#888'
                        },
                        beginAtZero: true
                    }
                }
            };
            
            // ROS Chart
            const rosCtx = document.getElementById('ros-chart').getContext('2d');
            rosChart = new Chart(rosCtx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Cumulative ROS (m/hr)',
                            data: cellData.ros,
                            borderColor: '#e85d04',
                            backgroundColor: 'rgba(232, 93, 4, 0.1)',
                            borderWidth: 2.5,
                            fill: true,
                            tension: 0.3,
                            pointRadius: 4,
                            pointBackgroundColor: '#e85d04',
                            pointBorderColor: '#fff',
                            pointBorderWidth: 2
                        },
                        {
                            label: 'ROS Increment (m/hr)',
                            data: cellData.rosIncrement,
                            borderColor: '#f97316',
                            backgroundColor: 'rgba(249, 115, 22, 0.05)',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false,
                            tension: 0.3,
                            pointRadius: 3,
                            pointBackgroundColor: '#f97316',
                            pointBorderColor: '#fff',
                            pointBorderWidth: 2
                        }
                    ]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            title: {
                                display: true,
                                text: 'Rate of Spread (m/hr)',
                                font: {
                                    family: "'Helvetica Neue', Helvetica, Arial, sans-serif",
                                    size: 11,
                                    weight: '600'
                                },
                                color: '#555'
                            }
                        }
                    }
                }
            });
            
            // Distance Chart (Cumulative + Increment)
            const incrementCtx = document.getElementById('increment-chart').getContext('2d');
            incrementChart = new Chart(incrementCtx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Cumulative Distance (m)',
                            data: cellData.displacement,
                            borderColor: '#3b82f6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            borderWidth: 2.5,
                            fill: true,
                            tension: 0.3,
                            pointRadius: 4,
                            pointBackgroundColor: '#3b82f6',
                            pointBorderColor: '#fff',
                            pointBorderWidth: 2
                        },
                        {
                            label: 'Distance Increment (m)',
                            data: cellData.distanceIncrement,
                            borderColor: '#8b5cf6',
                            backgroundColor: 'rgba(139, 92, 246, 0.05)',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false,
                            tension: 0.3,
                            pointRadius: 3,
                            pointBackgroundColor: '#8b5cf6',
                            pointBorderColor: '#fff',
                            pointBorderWidth: 2
                        }
                    ]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            title: {
                                display: true,
                                text: 'Distance (m)',
                                font: {
                                    family: "'Helvetica Neue', Helvetica, Arial, sans-serif",
                                    size: 11,
                                    weight: '600'
                                },
                                color: '#555'
                            }
                        }
                    }
                }
            });
        }

        // --- STATUS POPUP FUNCTIONS ---
        let statusHideTimeout = null;

        function showStatus(message, detail = '', type = 'loading') {
            const popup = document.getElementById('status-popup');
            const pill = document.getElementById('status-pill');
            const spinner = document.getElementById('status-spinner');
            const successIcon = document.getElementById('status-success-icon');
            const errorIcon = document.getElementById('status-error-icon');
            const messageEl = document.getElementById('status-message');
            const detailEl = document.getElementById('status-detail');

            // Clear any pending hide timeout
            if (statusHideTimeout) {
                clearTimeout(statusHideTimeout);
                statusHideTimeout = null;
            }

            // Reset animation
            popup.classList.remove('hiding');
            pill.style.animation = 'none';
            pill.offsetHeight; // Trigger reflow
            pill.style.animation = '';

            // Update content
            messageEl.textContent = message;
            detailEl.textContent = detail;

            // Show/hide icons based on type
            spinner.classList.toggle('hidden', type !== 'loading');
            successIcon.classList.toggle('hidden', type !== 'success');
            errorIcon.classList.toggle('hidden', type !== 'error');

            // Show popup
            popup.classList.add('visible');
        }

        function updateStatus(message, detail = '') {
            const messageEl = document.getElementById('status-message');
            const detailEl = document.getElementById('status-detail');
            messageEl.textContent = message;
            detailEl.textContent = detail;
        }

        function hideStatus(delay = 0) {
            const popup = document.getElementById('status-popup');
            
            if (delay > 0) {
                statusHideTimeout = setTimeout(() => {
                    popup.classList.add('hiding');
                    setTimeout(() => {
                        popup.classList.remove('visible', 'hiding');
                    }, 300);
                }, delay);
            } else {
                popup.classList.add('hiding');
                setTimeout(() => {
                    popup.classList.remove('visible', 'hiding');
                }, 300);
            }
        }

        function showStatusSuccess(message, detail = '') {
            showStatus(message, detail, 'success');
            hideStatus(2500);
        }

        function showStatusError(message, detail = '') {
            showStatus(message, detail, 'error');
            hideStatus(4000);
        }

        // --- WELCOME OVERLAY FUNCTIONS ---
        function toggleWelcomeContent() {
            const card = document.getElementById('welcome-card');
            card.classList.toggle('expanded');
        }

        function dismissWelcome() {
            const card = document.getElementById('welcome-card');
            const overlay = document.getElementById('welcome-overlay');
            
            card.classList.add('dismissing');
            
            // Wait for animation to complete before hiding
            setTimeout(() => {
                overlay.classList.add('dismissed');
            }, 400);
        }

        // --- MAP LAYERS ---
        const mapLayers = {
            default: L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> &copy; <a href="https://carto.com/">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 19
            }),
            satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '&copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
                maxZoom: 19
            }),
            terrain: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
                attribution: '&copy; Esri &mdash; Esri, DeLorme, NAVTEQ, TomTom, Intermap, iPC, USGS, FAO, NPS, NRCAN, GeoBase, Kadaster NL, Ordnance Survey, Esri Japan, METI, Esri China (Hong Kong), and the GIS User Community',
                maxZoom: 19
            })
        };

        let currentMapLayer = 'default';

        // --- MAP INITIALIZATION ---
        const map = L.map('map', {
            zoomControl: false
        }).setView([39.4871, -8.0801], 7);

        L.control.zoom({ position: 'bottomright' }).addTo(map);

        // Add default layer
        mapLayers.default.addTo(map);

        function setMapLayer(layerName) {
            // Remove current layer
            map.removeLayer(mapLayers[currentMapLayer]);
            
            // Add new layer
            mapLayers[layerName].addTo(map);
            currentMapLayer = layerName;
            
            // Update button states
            document.querySelectorAll('.map-layer-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`layer-${layerName}`).classList.add('active');
            
            // Ensure grid layer stays on top
            if (gridLayer) {
                gridLayer.bringToFront();
            }
        }

        const API_BASE_URL = 'http://localhost:5050/api';

        // State
        let gridLayer = null;
        let predictionsByDuration = {};
        let availableDurations = [];
        let currentDuration = 1;
        let currentViewMode = 'ros';  // 'ros', 'displacement', 'inputs'
        let currentMetricMode = 'cumulative';  // 'cumulative', 'increment'
        let inputVarRanges = {};
        let displacementRange = { min: 0, max: 1 };
        let rosRange = { min: 0, max: 2500 };
        let isPlaying = false;
        let playbackInterval = null;

        // --- TIME SINCE START SYNC FUNCTIONS ---
        function syncFromHours() {
            const hours = parseFloat(document.getElementById('f-start-hours').value) || 0;
            const totalMinutes = hours * 60;
            document.getElementById('f-start-minutes').value = Math.round(totalMinutes);
            checkFStartWarning();
        }

        function syncFromMinutes() {
            const minutes = parseFloat(document.getElementById('f-start-minutes').value) || 0;
            const hours = minutes / 60;
            document.getElementById('f-start-hours').value = parseFloat(hours.toFixed(2));
            checkFStartWarning();
        }

        function getTotalMinutes() {
            // Use minutes field as source of truth (it gets synced from hours)
            return parseFloat(document.getElementById('f-start-minutes').value) || 0;
        }

        function checkFStartWarning() {
            const minutes = getTotalMinutes();
            const warningEl = document.getElementById('f-start-warning');
            if (minutes > 1000) {
                warningEl.classList.remove('hidden');
            } else {
                warningEl.classList.add('hidden');
            }
        }

        // Helper function to generate timeline label based on metric mode
        function getTimelineLabelForDuration(dur) {
            if (currentMetricMode === 'cumulative') {
                return `0-${dur}h`;
            } else {
                // Increment mode
                return `${dur - 1}-${dur}h`;
            }
        }

        // Human-readable names for input variables
        const inputVarLabels = {
            'fuel_load': 'Fuel Load (tons/ha)',
            'pct_3_8': '% of area burned between 3 and 8 years ago',
            'pct_8p': '% of area burned more than 8 years ago',
            'wv100_kh': 'Wind at 100m (km/h)',
            'FWI_12h': 'Fire Weather Index'
        };

        // Color stops for ROS (green to red)
        const rosColorStops = [
            { pos: 0, r: 34, g: 197, b: 94 },
            { pos: 0.2, r: 132, g: 204, b: 22 },
            { pos: 0.4, r: 234, g: 179, b: 8 },
            { pos: 0.6, r: 249, g: 115, b: 22 },
            { pos: 0.8, r: 239, g: 68, b: 68 },
            { pos: 1, r: 185, g: 28, b: 28 }
        ];

        // Color stops for displacement (green to red, same as ROS)
        const displacementColorStops = [
            { pos: 0, r: 34, g: 197, b: 94 },
            { pos: 0.2, r: 132, g: 204, b: 22 },
            { pos: 0.4, r: 234, g: 179, b: 8 },
            { pos: 0.6, r: 249, g: 115, b: 22 },
            { pos: 0.8, r: 239, g: 68, b: 68 },
            { pos: 1, r: 185, g: 28, b: 28 }
        ];

        // Color stops for input variables (green to red, same as ROS)
        const inputColorStops = [
            { pos: 0, r: 34, g: 197, b: 94 },
            { pos: 0.2, r: 132, g: 204, b: 22 },
            { pos: 0.4, r: 234, g: 179, b: 8 },
            { pos: 0.6, r: 249, g: 115, b: 22 },
            { pos: 0.8, r: 239, g: 68, b: 68 },
            { pos: 1, r: 185, g: 28, b: 28 }
        ];

        function interpolateColor(t, colorStops) {
            let lower = colorStops[0];
            let upper = colorStops[colorStops.length - 1];

            for (let i = 0; i < colorStops.length - 1; i++) {
                if (t >= colorStops[i].pos && t <= colorStops[i + 1].pos) {
                    lower = colorStops[i];
                    upper = colorStops[i + 1];
                    break;
                }
            }

            const range = upper.pos - lower.pos;
            const localT = range === 0 ? 0 : (t - lower.pos) / range;

            const r = Math.round(lower.r + (upper.r - lower.r) * localT);
            const g = Math.round(lower.g + (upper.g - lower.g) * localT);
            const b = Math.round(lower.b + (upper.b - lower.b) * localT);

            return `rgb(${r}, ${g}, ${b})`;
        }

        function getColorForROS(ros) {
            const value = Math.max(0, Math.min(2500, ros));
            const t = value / 2500;
            return interpolateColor(t, rosColorStops);
        }

        function getColorForDisplacement(disp) {
            if (displacementRange.max === displacementRange.min) {
                return interpolateColor(0.5, displacementColorStops);
            }
            const t = (disp - displacementRange.min) / (displacementRange.max - displacementRange.min);
            return interpolateColor(Math.max(0, Math.min(1, t)), displacementColorStops);
        }

        function getColorForInputVar(value, varName) {
            const range = inputVarRanges[varName];
            if (!range || range.max === range.min) {
                return interpolateColor(0.5, inputColorStops);
            }
            const t = (value - range.min) / (range.max - range.min);
            return interpolateColor(Math.max(0, Math.min(1, t)), inputColorStops);
        }

        function setViewMode(mode) {
            currentViewMode = mode;
            
            document.getElementById('toggle-ros').classList.toggle('active', mode === 'ros');
            document.getElementById('toggle-displacement').classList.toggle('active', mode === 'displacement');
            document.getElementById('toggle-inputs').classList.toggle('active', mode === 'inputs');
            
            // Show/hide metric toggle (only for ros and displacement)
            document.getElementById('metric-toggle-container').classList.toggle('hidden', mode === 'inputs');
            
            // Show/hide input variable selector
            document.getElementById('input-var-selector-container').classList.toggle('hidden', mode !== 'inputs');
            
            // Show/hide legends
            document.getElementById('legend-ros').classList.toggle('hidden', mode !== 'ros');
            document.getElementById('legend-displacement').classList.toggle('hidden', mode !== 'displacement');
            document.getElementById('legend-inputs').classList.toggle('hidden', mode !== 'inputs');
            
            // Update stats labels
            updateStatsLabels();
            
            if (Object.keys(predictionsByDuration).length > 0) {
                drawGrid();
                updateStats();
            }
        }

        function setMetricMode(mode) {
            currentMetricMode = mode;
            
            document.getElementById('toggle-cumulative').classList.toggle('active', mode === 'cumulative');
            document.getElementById('toggle-increment').classList.toggle('active', mode === 'increment');
            
            // Update legend title
            if (currentViewMode === 'ros') {
                const title = mode === 'cumulative' ? 'Rate of Spread (m/hr)' : 'ROS Increment (m/hr)';
                document.getElementById('ros-legend-title').innerText = title;
            } else if (currentViewMode === 'displacement') {
                const title = mode === 'cumulative' ? 'Distance Traveled (m)' : 'Distance Increment (m)';
                document.getElementById('displacement-legend-title').innerText = title;
            }
            
            updateStatsLabels();
            
            if (Object.keys(predictionsByDuration).length > 0) {
                calculateRanges();
                updateLegendLabels();
                updateTimelineLabels();
                drawGrid();
                updateStats();
            }
        }

        function updateStatsLabels() {
            let unit = 'm/hr';
            if (currentViewMode === 'displacement') {
                unit = 'm';
            } else if (currentViewMode === 'inputs') {
                unit = '';
            }
            
            document.getElementById('min-label').innerText = `Min ${unit}`;
            document.getElementById('avg-label').innerText = `Avg ${unit}`;
            document.getElementById('max-label').innerText = `Max ${unit}`;
        }

        function updateInputVarDisplay() {
            const varName = document.getElementById('input-var-selector').value;
            
            document.getElementById('input-var-legend-title').innerText = inputVarLabels[varName] || varName;
            
            const range = inputVarRanges[varName];
            if (range) {
                const labels = document.getElementById('input-var-legend-labels');
                const step = (range.max - range.min) / 4;
                labels.innerHTML = `
                    <span>${range.min.toFixed(1)}</span>
                    <span>${(range.min + step).toFixed(1)}</span>
                    <span>${(range.min + step * 2).toFixed(1)}</span>
                    <span>${(range.min + step * 3).toFixed(1)}</span>
                    <span>${range.max.toFixed(1)}</span>
                `;
            }
            
            if (Object.keys(predictionsByDuration).length > 0) {
                drawGrid();
                updateStats();
            }
        }

        function calculateRanges() {
            // Calculate ranges across all durations for consistent coloring
            let allRos = [];
            let allDisplacement = [];
            let allIncrements = [];
            
            for (const dur of availableDurations) {
                const predictions = predictionsByDuration[dur] || [];
                predictions.forEach(p => {
                    allRos.push(p.ros);
                    allDisplacement.push(p.displacement);
                    if (p.increment !== undefined) {
                        allIncrements.push(p.increment);
                    }
                });
            }
            
            if (allRos.length > 0) {
                rosRange = {
                    min: 0,
                    max: Math.max(...allRos)
                };
            }
            
            if (currentMetricMode === 'increment' && allIncrements.length > 0) {
                displacementRange = {
                    min: 0,
                    max: Math.max(...allIncrements)
                };
            } else if (allDisplacement.length > 0) {
                displacementRange = {
                    min: 0,
                    max: Math.max(...allDisplacement)
                };
            }
            
            // Input variable ranges
            inputVarRanges = {};
            const varNames = ['fuel_load', 'pct_3_8', 'pct_8p', 'wv100_kh', 'FWI_12h'];
            
            varNames.forEach(varName => {
                const values = [];
                for (const dur of availableDurations) {
                    const predictions = predictionsByDuration[dur] || [];
                    predictions.forEach(p => {
                        if (p.input_vars && p.input_vars[varName] !== null && p.input_vars[varName] !== undefined) {
                            values.push(p.input_vars[varName]);
                        }
                    });
                }
                
                if (values.length > 0) {
                    inputVarRanges[varName] = {
                        min: Math.min(...values),
                        max: Math.max(...values)
                    };
                }
            });
        }

        function updateLegendLabels() {
            // Displacement legend (dynamic)
            const dispLabels = document.getElementById('displacement-legend-labels');
            const dispMax = displacementRange.max;
            const dispStep = dispMax / 4;
            dispLabels.innerHTML = `
                <span>0</span>
                <span>${Math.round(dispStep)}</span>
                <span>${Math.round(dispStep * 2)}</span>
                <span>${Math.round(dispStep * 3)}</span>
                <span>${Math.round(dispMax)}</span>
            `;
            
            // Update input var legend
            updateInputVarDisplay();
        }

        function updateTimelineLabels() {
            // Update tick labels based on current metric mode
            const ticks = document.querySelectorAll('.timeline-tick');
            ticks.forEach((tick, i) => {
                const dur = availableDurations[i];
                const labelEl = tick.querySelector('.tick-label');
                if (labelEl && dur !== undefined) {
                    labelEl.innerText = getTimelineLabelForDuration(dur);
                }
            });
            
            // Update main duration display
            updateDurationDisplay();
        }

        function drawGrid() {
            if (gridLayer) {
                map.removeLayer(gridLayer);
            }

            const predictions = predictionsByDuration[currentDuration] || [];
            if (predictions.length === 0) return;

            const rectangles = [];
            const selectedVar = document.getElementById('input-var-selector').value;

            predictions.forEach(pred => {
                const lat = pred.lat;
                const lon = pred.lon;
                
                let color;
                let displayValue;
                
                if (currentViewMode === 'ros') {
                    displayValue = currentMetricMode === 'increment' ? (pred.ros_increment || 0) : pred.ros;
                    color = getColorForROS(Math.abs(displayValue));
                } else if (currentViewMode === 'displacement') {
                    displayValue = currentMetricMode === 'increment' ? pred.increment : pred.displacement;
                    color = getColorForDisplacement(displayValue);
                } else {
                    const varValue = pred.input_vars ? pred.input_vars[selectedVar] : null;
                    displayValue = varValue;
                    color = varValue !== null ? getColorForInputVar(varValue, selectedVar) : '#cccccc';
                }

                const bounds = [
                    [lat - 0.05, lon - 0.05],
                    [lat + 0.05, lon + 0.05]
                ];

                // Build popup content with chart button
                let popupContent = `
                    <div style="font-family: Helvetica, sans-serif; font-size: 12px;">
                        <div style="font-weight: 600; margin-bottom: 6px; color: #1a1a1a;">Cell Info</div>
                        <div style="color: #666; line-height: 1.6;">
                            <div>Lat: ${lat.toFixed(4)}</div>
                            <div>Lon: ${lon.toFixed(4)}</div>
                            <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #eee;">
                                <div style="font-weight: 600; color: #1a1a1a; margin-bottom: 4px;">Prediction (${currentDuration}h)</div>
                                <div style="color: #e85d04; font-weight: 600;">ROS: ${pred.ros.toFixed(1)} m/hr</div>
                                <div style="color: #f97316;">ROS Δ: ${(pred.ros_increment || 0).toFixed(1)} m/hr</div>
                                <div style="color: #3b82f6;">Distance: ${pred.displacement.toFixed(1)} m</div>
                                <div style="color: #8b5cf6;">Distance Δ: ${(pred.increment || 0).toFixed(1)} m</div>
                                <div style="color: #888;">Error: ${pred.error_estimate.toFixed(1)}%</div>
                            </div>
                `;
                
                if (pred.input_vars) {
                    popupContent += `
                            <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #eee;">
                                <div style="font-weight: 600; color: #1a1a1a; margin-bottom: 4px;">Input Variables</div>
                    `;
                    
                    for (const [key, value] of Object.entries(pred.input_vars)) {
                        const label = inputVarLabels[key] || key;
                        const dispVal = value !== null ? value.toFixed(2) : 'N/A';
                        popupContent += `<div>${label}: ${dispVal}</div>`;
                    }
                    
                    popupContent += `</div>`;
                }
                
                // Add chart button
                popupContent += `
                            <button class="popup-chart-btn" onclick="openChartPane(${lat}, ${lon})">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <line x1="18" y1="20" x2="18" y2="10"></line>
                                    <line x1="12" y1="20" x2="12" y2="4"></line>
                                    <line x1="6" y1="20" x2="6" y2="14"></line>
                                </svg>
                                View Charts
                            </button>
                        </div>
                    </div>
                `;

                const rect = L.rectangle(bounds, {
                    color: color,
                    fillColor: color,
                    fillOpacity: 0.5,
                    weight: 0.5
                }).bindPopup(popupContent);

                rectangles.push(rect);
            });

            gridLayer = L.layerGroup(rectangles).addTo(map);
        }

        function updateStats() {
            const predictions = predictionsByDuration[currentDuration] || [];
            
            if (predictions.length === 0) {
                document.getElementById('min-ros-output').innerText = '—';
                document.getElementById('avg-ros-output').innerText = '—';
                document.getElementById('max-ros-output').innerText = '—';
                return;
            }
            
            let values;
            if (currentViewMode === 'ros') {
                values = currentMetricMode === 'increment'
                    ? predictions.map(p => p.ros_increment || 0)
                    : predictions.map(p => p.ros);
            } else if (currentViewMode === 'displacement') {
                values = currentMetricMode === 'increment' 
                    ? predictions.map(p => p.increment || 0)
                    : predictions.map(p => p.displacement);
            } else {
                const selectedVar = document.getElementById('input-var-selector').value;
                values = predictions
                    .map(p => p.input_vars ? p.input_vars[selectedVar] : null)
                    .filter(v => v !== null && v !== undefined);
            }
            
            if (values.length === 0) {
                document.getElementById('min-ros-output').innerText = '—';
                document.getElementById('avg-ros-output').innerText = '—';
                document.getElementById('max-ros-output').innerText = '—';
                return;
            }
            
            const minVal = Math.min(...values);
            const avgVal = values.reduce((a, b) => a + b, 0) / values.length;
            const maxVal = Math.max(...values);
            
            document.getElementById('min-ros-output').innerText = minVal.toFixed(1);
            document.getElementById('avg-ros-output').innerText = avgVal.toFixed(1);
            document.getElementById('max-ros-output').innerText = maxVal.toFixed(1);
        }

        function setupTimeline() {
            const slider = document.getElementById('timeline-slider');
            const ticksContainer = document.getElementById('timeline-ticks');
            
            if (availableDurations.length <= 1) {
                document.getElementById('timeline-panel').classList.add('hidden');
                return;
            }
            
            document.getElementById('timeline-panel').classList.remove('hidden');
            
            const minDur = Math.min(...availableDurations);
            const maxDur = Math.max(...availableDurations);
            
            slider.min = minDur;
            slider.max = maxDur;
            slider.value = currentDuration;
            
            // Create tick marks
            ticksContainer.innerHTML = '';
            availableDurations.forEach(dur => {
                const tick = document.createElement('div');
                tick.className = `timeline-tick${dur === currentDuration ? ' active' : ''}`;
                tick.innerHTML = `
                    <div class="tick-dot"></div>
                    <span class="tick-label">${getTimelineLabelForDuration(dur)}</span>
                `;
                tick.onclick = () => onTimelineChange(dur);
                ticksContainer.appendChild(tick);
            });
            
            updateDurationDisplay();
        }

        function updateDurationDisplay() {
            const displayEl = document.getElementById('current-duration-display');
            
            // Show range based on metric mode
            displayEl.innerText = getTimelineLabelForDuration(currentDuration);
            
            // Update tick active states
            const ticks = document.querySelectorAll('.timeline-tick');
            ticks.forEach((tick, i) => {
                tick.classList.toggle('active', availableDurations[i] === currentDuration);
            });
        }

        function onTimelineChange(value) {
            currentDuration = parseInt(value);
            document.getElementById('timeline-slider').value = currentDuration;
            updateDurationDisplay();
            drawGrid();
            updateStats();
        }

        function stepBackward() {
            const idx = availableDurations.indexOf(currentDuration);
            if (idx > 0) {
                onTimelineChange(availableDurations[idx - 1]);
            }
        }

        function stepForward() {
            const idx = availableDurations.indexOf(currentDuration);
            if (idx < availableDurations.length - 1) {
                onTimelineChange(availableDurations[idx + 1]);
            }
        }

        function togglePlayback() {
            isPlaying = !isPlaying;
            
            document.getElementById('play-icon').classList.toggle('hidden', isPlaying);
            document.getElementById('pause-icon').classList.toggle('hidden', !isPlaying);
            
            if (isPlaying) {
                playbackInterval = setInterval(() => {
                    const idx = availableDurations.indexOf(currentDuration);
                    if (idx < availableDurations.length - 1) {
                        onTimelineChange(availableDurations[idx + 1]);
                    } else {
                        // Loop back to start
                        onTimelineChange(availableDurations[0]);
                    }
                }, 1000);
            } else {
                clearInterval(playbackInterval);
                playbackInterval = null;
            }
        }

        async function runGridPrediction() {
            // Stop any playback
            if (isPlaying) {
                togglePlayback();
            }
            
            const datetimeValue = document.getElementById('datetime-input').value;
            const fStartValue = getTotalMinutes();
            const durationValue = parseInt(document.getElementById('duration-input').value) || 1;
            const modelType = document.getElementById('model-selector').value;

            if (!datetimeValue) {
                showStatusError('Missing Input', 'Please select a date and time');
                return;
            }

            const datetime = datetimeValue.replace('T', ' ');

            // Show initial status
            showStatus('Connecting...', 'Establishing connection');

            document.getElementById('min-ros-output').innerHTML = '<div class="loader"></div>';
            document.getElementById('avg-ros-output').innerHTML = '<div class="loader"></div>';
            document.getElementById('max-ros-output').innerHTML = '<div class="loader"></div>';

            // Disable run button during request
            const runBtn = document.getElementById('run-btn');
            runBtn.disabled = true;
            runBtn.style.opacity = '0.6';
            runBtn.style.cursor = 'not-allowed';

            if (gridLayer) {
                map.removeLayer(gridLayer);
            }

            // Build SSE URL with query parameters
            const params = new URLSearchParams({
                datetime: datetime,
                model: modelType,
                f_start: fStartValue,
                duration_p: durationValue
            });
            
            const sseUrl = `${API_BASE_URL}/predict-grid-sse?${params.toString()}`;
            
            // Create EventSource for SSE
            const eventSource = new EventSource(sseUrl);
            
            // Handle progress events
            eventSource.addEventListener('progress', (event) => {
                const data = JSON.parse(event.data);
                updateStatus(data.message, data.detail || '');
                console.log('Progress:', data.stage, data.message);
            });
            
            // Handle completion
            eventSource.addEventListener('complete', (event) => {
                const data = JSON.parse(event.data);
                eventSource.close();
                
                if (data.success) {
                    predictionsByDuration = data.predictions_by_duration;
                    availableDurations = data.durations;
                    currentDuration = availableDurations.length > 0 ? availableDurations[0] : 1;

                    if (availableDurations.length > 0) {
                        calculateRanges();
                        updateLegendLabels();
                        setupTimeline();
                        drawGrid();
                        updateStats();
                        updateExportButtonState();
                        showStatusSuccess('Prediction Complete', `${availableDurations.length} time steps processed`);
                    } else {
                        document.getElementById('min-ros-output').innerText = '—';
                        document.getElementById('avg-ros-output').innerText = '—';
                        document.getElementById('max-ros-output').innerText = '—';
                        document.getElementById('timeline-panel').classList.add('hidden');
                        updateExportButtonState();
                        showStatusError('No Data', 'Check data availability for selected date');
                    }
                } else {
                    handlePredictionError(data.error || 'Unknown error');
                }
                
                // Re-enable run button
                runBtn.disabled = false;
                runBtn.style.opacity = '';
                runBtn.style.cursor = '';
            });
            
            // Handle errors
            eventSource.addEventListener('error', (event) => {
                // Check if this is a custom error event from our backend
                if (event.data) {
                    const data = JSON.parse(event.data);
                    eventSource.close();
                    handlePredictionError(data.message);
                } else {
                    // Connection error
                    eventSource.close();
                    handlePredictionError('Connection lost. Please try again.');
                }
                
                // Re-enable run button
                runBtn.disabled = false;
                runBtn.style.opacity = '';
                runBtn.style.cursor = '';
            });
            
            // Handle connection errors (EventSource built-in)
            eventSource.onerror = (error) => {
                // Only handle if not already closed
                if (eventSource.readyState === EventSource.CLOSED) {
                    return;
                }
                
                console.error('SSE Error:', error);
                eventSource.close();
                handlePredictionError('Connection error. Please try again.');
                
                // Re-enable run button
                runBtn.disabled = false;
                runBtn.style.opacity = '';
                runBtn.style.cursor = '';
            };
        }

        function handlePredictionError(message) {
            console.error('Prediction Error:', message);
            document.getElementById('min-ros-output').innerText = '—';
            document.getElementById('avg-ros-output').innerText = '—';
            document.getElementById('max-ros-output').innerText = '—';
            document.getElementById('timeline-panel').classList.add('hidden');
            updateExportButtonState();
            showStatusError('Request Failed', message);
        }

        // Close chart pane with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeChartPane();
            }
        });
    </script>
</body>

</html>